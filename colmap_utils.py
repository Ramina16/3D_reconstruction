import os
import subprocess
import numpy as np
import struct


def read_next_bytes(fid, num_bytes, format_char_sequence, endian_character="<"):
    """
    Read and unpack the next bytes from a binary file

    :param fid:
    :param num_bytes: Sum of combination of {2, 4, 8}, e.g. 2, 6, 16, 30, etc
    :param format_char_sequence: List of {c, e, f, d, h, H, i, I, l, L, q, Q}
    :param endian_character: Any of {@, =, <, >, !}
    :return: Tuple of read and unpacked values
    """
    data = fid.read(num_bytes)
    return struct.unpack(endian_character + format_char_sequence, data)


def run_colmap(basedir, match_type):
    
    logfile_name = os.path.join(basedir, 'colmap_output.txt')
    logfile = open(logfile_name, 'w')
    
    feature_extractor_args = [
        'colmap', 'feature_extractor', 
            '--database_path', os.path.join(basedir, 'database.db'), 
            '--image_path', os.path.join(basedir, 'images'),
            '--ImageReader.single_camera', '1',
    ]
    feat_output = ( subprocess.check_output(feature_extractor_args, universal_newlines=True) )
    logfile.write(feat_output)
    print('Features extracted')

    exhaustive_matcher_args = [
        'colmap', match_type, 
            '--database_path', os.path.join(basedir, 'database.db'), 
    ]

    match_output = ( subprocess.check_output(exhaustive_matcher_args, universal_newlines=True) )
    logfile.write(match_output)
    print('Features matched')
    
    p = os.path.join(basedir, 'sparse')
    if not os.path.exists(p):
        os.makedirs(p)

    mapper_args = [
        'colmap', 'mapper',
            '--database_path', os.path.join(basedir, 'database.db'),
            '--image_path', os.path.join(basedir, 'images'),
            '--output_path', os.path.join(basedir, 'sparse'),
            '--Mapper.num_threads', '16',
            '--Mapper.init_min_tri_angle', '4',
            '--Mapper.multiple_models', '0',
            '--Mapper.extract_colors', '0',
    ]

    map_output = ( subprocess.check_output(mapper_args, universal_newlines=True) )
    logfile.write(map_output)
    logfile.close()
    print('Sparse map created')
    
    print( 'Finished running COLMAP, see {} for logs'.format(logfile_name) )


def run_colmap_dense(workspace_path):
    dense_output_path = os.path.join(workspace_path, "dense")

    os.makedirs(dense_output_path, exist_ok=True)

    # Run dense stereo matching without GPU
    command = [
        "colmap", "patch_match_stereo",
        "--workspace_path", workspace_path,
        "--workspace_format", "COLMAP",
        "--PatchMatchStereo.geom_consistency", "true",
        "--PatchMatchStereo.num_threads", "8",  # Adjust based on your CPU cores
        "--PatchMatchStereo.device", "CPU"  # Force CPU usage
    ]

    try:
        output = subprocess.check_output(command, stderr=subprocess.STDOUT, text=True)
        print(output)  # Print the command's output for debugging
    except subprocess.CalledProcessError as e:
        print(f"Error while running command: {e.cmd}")
        print(f"Exit code: {e.returncode}")
        print(f"Output:\n{e.output}")
        raise


def gen_poses(basedir, match_type, factors=None):
    
    files_needed = ['{}.bin'.format(f) for f in ['cameras', 'images', 'points3D']]
    if os.path.exists(os.path.join(basedir, 'sparse/0')):
        files_had = os.listdir(os.path.join(basedir, 'sparse/0'))
    else:
        files_had = []
    if not all([f in files_had for f in files_needed]):
        print( 'Need to run COLMAP' )
        run_colmap(basedir, match_type)
    else:
        print('Don\'t need to run COLMAP')


def read_points3d_binary(path_to_model_file):
    """
    read 3D points from binary file generated by COLMAP
    """
    points = []
    colors = []
    with open(os.path.join(path_to_model_file, 'points3D.bin'), "rb") as fid:
        num_points = read_next_bytes(fid, 8, "Q")[0]
        for _ in range(num_points):
            # Read a single point: ID (Q), x, y, z (ddd), R, G, B (BBB), error (d)
            binary_data = read_next_bytes(
                fid, num_bytes=43, format_char_sequence="QdddBBBd"
            )

            # Convert xyz to float32
            xyz = np.array(binary_data[1:4], dtype=np.float32)  # Convert to float32
            rgb = np.array(binary_data[4:7], dtype=np.uint8)     # RGB remains uint8
            points.append(xyz)
            colors.append(rgb)

            track_length = read_next_bytes(
                fid, num_bytes=8, format_char_sequence="Q"
            )[0]

            track_elems = read_next_bytes(
                fid,
                num_bytes=8 * track_length,
                format_char_sequence="ii" * track_length,
            )

    return points, colors
